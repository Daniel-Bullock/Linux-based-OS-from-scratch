/* rtc.c - Functions to interact with the rtc */

#include "rtc.h"
#include "i8259.h"
#include "lib.h"
#include "terminal_driver.h"


/* Initializes RTC, turns on periodic interrupts, and enables
 * the associated IRQ on the PIC 
 *      INPUTS: none
 *      OUTPUTS: none
 *      RETURN VALUE: none
 *      SIDE EFFECTS: Sets interrupt flag, enables interrupts from the RTC,
 *                    and RTC will generate periodic interrupts at 2 Hz
 */
void rtc_init(){
    uint8_t prev;
    outb(0x8B, RTC_PORT);   // disable NMI (bit 7), select Status Register B
    prev = inb(CMOS_PORT);
    outb(0x8B, RTC_PORT);   // set index again
    outb((prev|0x40), CMOS_PORT);   // turns on periodic interrupts (bit 6 in Status Register B)
    enable_irq(RTC_IRQ);
    outb(0x8A, RTC_PORT);   // set index again
    outb(0x06, CMOS_PORT);   // set rate selector to 0110 (1024 Hz)

    int i;
    for (i=0; i<MAX_TERMINALS; i++) {
        terminal_data[active_terminal].rtc_divider = RTC_RATE / 2;     // set rtc frequency to 2 Hz
        terminal_data[active_terminal].rtc_counter = 0;
    }
}

/* Handles interrupts generated by the RTC
 *  INPUTS: none
 *  OUTPUTS: none
 *  RETURN VALUE: none
 *  SIDE EFFECTS: Calls test_interrupts, which prints onto the screen
 */
void rtc_handler(){
    outb(0x0C, RTC_PORT);	// select register C
    inb(CMOS_PORT);		    // just throw away contents

    int i;
    for (i = 0; i < MAX_TERMINALS; i++) {
        //terminal_data[i].rtc_interrupt_received = 0;
        terminal_data[i].rtc_counter++;
        if(terminal_data[i].rtc_counter >= terminal_data[i].rtc_divider){
            //test_interrupts();
            terminal_data[i].rtc_counter = 0;
            terminal_data[i].rtc_interrupt_received = 1;
        }
    }

    send_eoi(RTC_IRQ);
}


/* Initializes rtc frequency to 2 Hz
 *  INPUTS: defined but not used
 *  OUTPUTS: sets terminal_data[active_terminal].rtc_counter to 0, divider to RTC_RATE/2
 *  RETURN VALUE: none
 *  SIDE EFFECTS: none
 */
int32_t rtc_open(file_desc_t *fd, const uint8_t* filename){
    terminal_data[active_terminal].rtc_divider = RTC_RATE / 2;     // set rtc frequency to 2 Hz
    terminal_data[active_terminal].rtc_counter = 0;
    fd->flags.open = 1;
    return 0;
}

/* Doesn't really do anything but still need to define
 *  INPUTS: defined but not used
 *  OUTPUTS: none
 *  RETURN VALUE: 0
 *  SIDE EFFECTS: none
 */
int32_t rtc_close(file_desc_t *fd){
    terminal_data[active_terminal].rtc_counter = 0;
    terminal_data[active_terminal].rtc_divider = RTC_RATE / 2;
    fd->flags.open = 0;
    return 0;
}

/* Waits until interrupt has occurred
 *  INPUTS: defined but not used
 *  OUTPUTS: none
 *  RETURN VALUE: 0
 *  SIDE EFFECTS: spins in while loop until rtc interrupt occurs
 */
int32_t rtc_read(file_desc_t *fd, void* buf, int32_t nbytes){
    sti();
    while(terminal_data[active_terminal].rtc_interrupt_received == 0){
        // wait until interrupt occurs
    }
    terminal_data[active_terminal].rtc_interrupt_received = 0;
    return 0;
}

/* Changes the rtc frequency
 *  INPUTS: int32_t fd - not used
 *          void* buf - buffer of data containing new frequency, must be power of 2
 *          int32_t nbytes - number of bytes in buf, must be 4
 *  OUTPUTS: none
 *  RETURN VALUE: -1 if unsuccessful, nbytes if success
 *  SIDE EFFECTS: changes rtc virtual frequency
 */
int32_t rtc_write(file_desc_t *fd, const void* buf, int32_t nbytes){
    int32_t buffer;
    if(nbytes != 4 || buf == NULL){ // only accepts writes of 4 bytes
        return -1;
    }
    
    buffer = *(int32_t*)buf;
    if((buffer != 0) && ((buffer & (buffer - 1)) == 0)){    // check if power of 2
        if(buffer <= RTC_RATE){
            terminal_data[active_terminal].rtc_divider = RTC_RATE / buffer;
            terminal_data[active_terminal].rtc_counter = 0;
        }else{
            return -1;
        }

    }else{
        return -1;
    }

    return nbytes;   // return number of bytes written

}

